repeat task.wait() until game:IsLoaded()

local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local playerCharacter = player.Character
local playerCamera = Workspace.CurrentCamera

local TargetedPlayer = nil
local TargetedPlayerCharacter = nil
local TargetedPlayerAimPart = nil

local Silent = {
    Settings = {
        Toggled = true,
        AimPart = "HumanoidRootPart",
        HitChance = 500,
        Prediction = {
            Toggled = true,
            Horizontal = 0.12842,
            Vertical = 0.12842,
        },
        Circle = {
            Visible = false,
            Color = Color3.fromRGB(0, 255, 255),
            Transparency = 0.5,
            Thickness = 1,
            NumSides = 1000,
            Radius = 180, -- Adjust the FOV circle radius as needed
            Filled = false,
        },
    },
}

local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = Silent.Settings.Circle.Visible
FOVCircle.Color = Silent.Settings.Circle.Color
FOVCircle.Transparency = Silent.Settings.Circle.Transparency
FOVCircle.Thickness = Silent.Settings.Circle.Thickness
FOVCircle.NumSides = Silent.Settings.Circle.NumSides
FOVCircle.Radius = Silent.Settings.Circle.Radius
FOVCircle.Filled = Silent.Settings.Circle.Filled

local function GetClosestPlayer()
    local ClosestPlayer = nil
    local ShortestDistance = math.huge

    for _, Player in ipairs(Players:GetPlayers()) do
        if Player ~= player and Player.Character then
            local PlayerPart = Player.Character:FindFirstChild(Silent.Settings.AimPart)
            if PlayerPart and PlayerPart:IsA("BasePart") then
                local PlayerScreenPosition = playerCamera:WorldToViewportPoint(PlayerPart.Position)
                local MagnitudeDistance = (Vector2.new(PlayerScreenPosition.X, PlayerScreenPosition.Y) - Vector2.new(playerCamera.ViewportSize.X / 2, playerCamera.ViewportSize.Y / 2)).Magnitude
                
                if MagnitudeDistance <= FOVCircle.Radius then
                    ClosestPlayer = Player
                    ShortestDistance = MagnitudeDistance
                end
            end
        end
    end
    return ClosestPlayer
end

RunService.RenderStepped:Connect(function()
    TargetedPlayer = GetClosestPlayer()
    if TargetedPlayer and TargetedPlayer.Character and TargetedPlayer.Character:WaitForChild(Silent.Settings.AimPart) then
        TargetedPlayerCharacter = TargetedPlayer.Character
        TargetedPlayerAimPart = TargetedPlayerCharacter:WaitForChild(Silent.Settings.AimPart)
    end
    
    FOVCircle.Position = Vector2.new(playerCamera.ViewportSize.X / 2, playerCamera.ViewportSize.Y / 2)
end)

local RawMetaTable = getrawmetatable(game)
local OldRawMetaTable = RawMetaTable.__namecall
setreadonly(RawMetaTable, false)

math.randomseed(os.time())

RawMetaTable.__namecall = newcclosure(function(...)
    local RemoteArguments = {...}

    if Silent.Settings.Toggled and getnamecallmethod() == "FireServer" and TargetedPlayer and TargetedPlayerCharacter and TargetedPlayerAimPart then
        local VelocityPrediction = Vector3.new(TargetedPlayerAimPart.Velocity.X * Silent.Settings.Prediction.Horizontal, TargetedPlayerAimPart.Velocity.Y * Silent.Settings.Prediction.Vertical, TargetedPlayerAimPart.Velocity.Z * Silent.Settings.Prediction.Horizontal)
        local Hit_Success = math.random(100) <= Silent.Settings.HitChance
        
        if (RemoteArguments[2] == "UpdateMousePos" and type(RemoteArguments[3]) ~= "table") or (RemoteArguments[2] == "MousePos" and type(RemoteArguments[3]) ~= "table") or (RemoteArguments[2] == "MOUSE" and type(RemoteArguments[3]) ~= "table") then 
            
            if Hit_Success then
                if Silent.Settings.Prediction.Toggled then
                    RemoteArguments[3] = TargetedPlayerAimPart.Position + VelocityPrediction
                elseif not Silent.Settings.Prediction.Toggled then
                    RemoteArguments[3] = TargetedPlayerAimPart.Position
                end
            end
            
        elseif (RemoteArguments[2] == "UpdateMousePos" and type(RemoteArguments[3]) == "table" and RemoteArguments[3]["MousePos"] and RemoteArguments[3]["Camera"] and not RemoteArguments[3][1] and not RemoteArguments[3][2]) then
            
            if Hit_Success then
                if Silent.Settings.Prediction.Toggled then
                    RemoteArguments[3] = {
                        ["MousePos"] = TargetedPlayerAimPart.Position + VelocityPrediction,
                        ["Camera"] = TargetedPlayerAimPart.Position + VelocityPrediction
                    }
                elseif not Silent.Settings.Prediction.Toggled then
                    RemoteArguments[3] = {
                        ["MousePos"] = TargetedPlayerAimPart.Position,
                        ["Camera"] = TargetedPlayerAimPart.Position
                    }
                end
            end
            
        elseif (RemoteArguments[2] == "UpdateMousePos" and type(RemoteArguments[3]) == "table" and not RemoteArguments[3]["MousePos"] and not RemoteArguments[3]["Camera"] and RemoteArguments[3][1] and RemoteArguments[3][2]) then
            
            if Hit_Success then
                if Silent.Settings.Prediction.Toggled then
                    RemoteArguments[3] = {
                        [1] = TargetedPlayerAimPart.Position + VelocityPrediction,
                        [2] = TargetedPlayerAimPart.Position + VelocityPrediction
                    }
                elseif not Silent.Settings.Prediction.Toggled then
                    RemoteArguments[3] = {
                        [1] = TargetedPlayerAimPart.Position,
                        [2] = TargetedPlayerAimPart.Position
                    }
                end
            end
            
        end
        
        return OldRawMetaTable(unpack(RemoteArguments))
    end
    return OldRawMetaTable(...)
end)

workspace.CurrentCamera.FieldOfView = 76

-- Get necessary services
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")

-- Function to apply color correction
local function applyColorCorrection()
    -- Get player's camera
    local player = Players.LocalPlayer
    local camera = game.Workspace.CurrentCamera

    -- Ensure the camera exists
    if not camera then
        return
    end

    -- Create a ColorCorrectionEffect
    local colorCorrection = Instance.new("ColorCorrectionEffect")
    colorCorrection.Parent = Lighting

    -- Adjust settings for watery, glassy effect
    colorCorrection.Brightness = 0.1
    colorCorrection.Contrast = 0.2
    colorCorrection.Saturation = 0.7
    colorCorrection.TintColor = Color3.fromRGB(150, 200, 255) -- Sky-blue tint

    -- Function to update effect settings
    local function updateColorCorrection()
        -- Check if the player's character and camera exist
        if player.Character and camera and camera:IsA("Camera") then
            -- Attach the camera to the player's character
            camera.CameraType = Enum.CameraType.Custom
            camera.CameraSubject = player.Character.Humanoid
        end
    end

    -- Connect update function to RenderStepped event
    local connection
    connection = RunService.RenderStepped:Connect(function()
        updateColorCorrection()
    end)

    -- Disconnect the connection when player leaves
    player.CharacterRemoving:Connect(function()
        if connection then
            connection:Disconnect()
        end
    end)
end

-- Apply color correction when player joins
applyColorCorrection()

getgenv().Resolution = {
    [".gg/scripters"] = 0.90
}

local Camera = workspace.CurrentCamera
if getgenv().gg_scripters == nil then
    game:GetService("RunService").RenderStepped:Connect(
        function()
            Camera.CFrame = Camera.CFrame * CFrame.new(0, 0, 0, 1, 0, 0, 0, getgenv().Resolution[".gg/scripters"], 0, 0, 0, 1)
        end
    )
end
getgenv().gg_scripters = "Aori0001"

local ToDisable = {
	Textures = false,
	VisualEffects = true,
	Parts = false,
	Particles = false,
	Sky = false
}

local ToEnable = {
	FullBright = false
}

local Stuff = {}

for _, v in next, game:GetDescendants() do
	if ToDisable.Parts then
		if v:IsA("Part") or v:IsA("Union") or v:IsA("BasePart") then
			v.Material = Enum.Material.SmoothPlastic
			table.insert(Stuff, 1, v)
		end
	end
	
	if ToDisable.Particles then
		if v:IsA("ParticleEmitter") or v:IsA("Smoke") or v:IsA("Explosion") or v:IsA("Sparkles") or v:IsA("Fire") then
			v.Enabled = false
			table.insert(Stuff, 1, v)
		end
	end
	
	if ToDisable.VisualEffects then
		if v:IsA("BloomEffect") or v:IsA("BlurEffect") or v:IsA("DepthOfFieldEffect") or v:IsA("SunRaysEffect") then
			v.Enabled = false
			table.insert(Stuff, 1, v)
		end
	end
	
	if ToDisable.Textures then
		if v:IsA("Decal") or v:IsA("Texture") then
			v.Texture = ""
			table.insert(Stuff, 1, v)
		end
	end
	
	if ToDisable.Sky then
		if v:IsA("Sky") then
			v.Parent = nil
			table.insert(Stuff, 1, v)
		end
	end
end

game:GetService("TestService"):Message("Effects Disabler Script : Successfully disabled "..#Stuff.." assets / effects. Settings :")

for i, v in next, ToDisable do
	print(tostring(i)..": "..tostring(v))
end

if ToEnable.FullBright then
    local Lighting = game:GetService("Lighting")
    
    Lighting.FogColor = Color3.fromRGB(255, 255, 255)
    Lighting.FogEnd = math.huge
    Lighting.FogStart = math.huge
    Lighting.Ambient = Color3.fromRGB(255, 255, 255)
    Lighting.Brightness = 5
    Lighting.ColorShift_Bottom = Color3.fromRGB(255, 255, 255)
    Lighting.ColorShift_Top = Color3.fromRGB(255, 255, 255)
    Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
    Lighting.Outlines = true
end

local images = {
    "http://www.roblox.com/asset/?id=600830446",
    "http://www.roblox.com/asset/?id=600830446",
    "http://www.roblox.com/asset/?id=600830446",
    "http://www.roblox.com/asset/?id=600830446",
    "http://www.roblox.com/asset/?id=6489194051",
    "http://www.roblox.com/asset/?id=600830446",
    "http://www.roblox.com/asset/?id=600830446",
    "http://www.roblox.com/asset/?id=600830446"
}

local Spooky = Instance.new("Sound", game.Workspace)
Spooky.Name = "Spooky"
Spooky.SoundId = "rbxassetid://88i"
Spooky.Volume = 1500
Spooky.Looped = false
Spooky:Play()

local Sky = Instance.new("Sky", game.Lighting)

while true do
    for _, image in ipairs(images) do
        Sky.SkyboxBk = image
        Sky.SkyboxDn = image
        Sky.SkyboxFt = image
        Sky.SkyboxLf = image
        Sky.SkyboxRt = image
        Sky.SkyboxUp = image
        wait(0.25)
    end
end

-- Intro Script

-- Define the main settings for the intro
local MainSettings = {
    Intro = true,
    Version = "Latest"
}

-- Function to create and display the intro splash screen
if MainSettings.Intro then
    local cam = workspace.CurrentCamera
    local x = cam.ViewportSize.X
    local y = cam.ViewportSize.Y
    local newx = math.floor(x * 0.5)
    local newy = math.floor(y * 0.5)

    local SpashScreen = Instance.new("ScreenGui")
    local Image = Instance.new("ImageLabel")
    SpashScreen.Name = "SpashScreen"
    SpashScreen.Parent = game.CoreGui
    SpashScreen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    Image.Name = "Image"
    Image.Parent = SpashScreen
    Image.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    Image.BackgroundTransparency = 1
    Image.Position = UDim2.new(0, newx, 0, newy)
    Image.Size = UDim2.new(0, 793, 0, 392)
    Image.Image = "rbxassetid://13858594439"
    Image.ImageTransparency = 1
    Image.AnchorPoint = Vector2.new(0.5, 0.5)

    local Blur = Instance.new("BlurEffect")
    Blur.Parent = game.Lighting
    Blur.Size = 0
    Blur.Name = tostring(math.random(1, 123123))

    local function gui(element, properties, duration, easingStyle, easingDirection)
        local tweenInfo = TweenInfo.new(duration or 1, easingStyle or Enum.EasingStyle.Sine, easingDirection or Enum.EasingDirection.InOut)
        local tween = game:GetService("TweenService"):Create(element, tweenInfo, properties)
        tween:Play()
    end

    gui(Image, {ImageTransparency = 0}, 0.3)
    gui(Blur, {Size = 20}, 0.3)
    wait(3)
    gui(Image, {ImageTransparency = 1}, 0.3)
    gui(Blur, {Size = 0}, 0.3)
    wait(0.3)
end
